<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Rendering - Z Buffer | Osman Jiménez's blog</title><meta name="description"><meta name="generator" content="Osman Jiménez's blog"><meta name="author" content="Osman Jimenez"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Osman Jiménez's blog" title="Osman Jiménez's blog"></a><h1><a href="/" alt="Osman Jiménez's blog" title="Osman Jiménez's blog" itemprop="headline">Osman Jiménez's blog</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Rendering - Z Buffer</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2017-08-25T04:04:27.000Z"> Thursday, August 24th 2017 at 23:04</time><br>Last updated on<time itemprop="dateModified" datetime="2017-08-25T04:04:27.000Z"> Friday, September 29th 2017 at 17:37</time></span><p>En estos dias estuve revisando este algoritmo para renderizacion, y les voy contar un poco de que se trata.</p>
<h2 id="¿Para-que-sirve"><a href="#¿Para-que-sirve" class="headerlink" title="¿Para qué sirve?"></a>¿Para qué sirve?</h2><p>En computacion grafica suele aparecer el problema de como renderizar los objetos en la pantalla, como saber cual objeto esta delante de cual, cual esta detras. y que objetos son visibles por la cámara. Este algoritmo intenta resolver de manera eficiente este problema. </p>
<h2 id="¿Como-funciona"><a href="#¿Como-funciona" class="headerlink" title="¿Cómo funciona?"></a>¿Cómo funciona?</h2><p>La idea detras del algoritmo es bastante simple. Lo primero que se hace es definir para cada uno de los objetos que se quieren renderizar, la profundidad (que tan lejos de la camara) a la que esta. Esto lo hacemos para cada pixel del objeto. Además de esto, tambien se asigna un color a los pixeles, (el color de ese pixel en el objeto).  La forma mas facil de representar esto es usando matrices, cada columna representado la posicion en Y, y la columna la posicion X. Normalmente se asignan valores entre [0, 1] a la profunidad, pero eso ya depende de cada quien.<br>Una vez hecho esto, lo que prosigue es llenar el z buffer, que es el que nos va a ayudar a dibujar (se llama z buffer, porque guarda los valores de z para cada pixel). Inicialmente el buffer tendra en cada pixel el valor de infinito, indicando que no hay nada para dibujar. Luego empezamos a llenar el buffer con la informacion de cada objeto uno por uno, sin importar el orden en que se haga. Para cada pixel se mira la profundidad actual que tiene almacenada el buffer, y la del objeto. En caso de que el objeto tenga una profundidad menor, se actualiza el z buffer con la nueva profundidad, y el color que se debe pintar en ese pixel. Una vez procesados todos los objetos, solo resta dibujar la informacion que quedo en el buffer, y woala!, se vera una imagen con profundidad.</p>
<p>Inline-style:<br><img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 1"><br><img src="https://github.com/osdajigu/osdajigu.github.io/blob/master/images/mstile-70x70.png" alt="Zbuffering" title="dasdas"><br><img src="/public/images/mstile-70x70.png" alt="Zbuffering"><br><img src="https://raw.githubusercontent.com/i-saumitra/Voice-controlled-MP3-Player/master/screenshot.jpg" alt="ScreenShot"></p>
</article></main></body></html>