<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Rendering - Z Buffer | Osman Jiménez's blog</title><meta name="description"><meta name="generator" content="Osman Jiménez's blog"><meta name="author" content="Osman Jimenez"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Osman Jiménez's blog" title="Osman Jiménez's blog"></a><h1><a href="/" alt="Osman Jiménez's blog" title="Osman Jiménez's blog" itemprop="headline">Osman Jiménez's blog</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">Rendering - Z Buffer</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2017-08-25T04:04:27.000Z"> Thursday, August 24th 2017 at 23:04</time><br>Last updated on<time itemprop="dateModified" datetime="2017-08-25T04:04:27.000Z"> Friday, September 29th 2017 at 22:31</time></span><p>En estos dias estuve revisando este algoritmo para renderizacion, y les voy contar un poco de que se trata.</p>
<h2 id="¿Para-que-sirve"><a href="#¿Para-que-sirve" class="headerlink" title="¿Para qué sirve?"></a>¿Para qué sirve?</h2><p>En computacion grafica suele aparecer el problema de como renderizar los objetos en la pantalla, como saber cual objeto esta delante de cual, cual esta detras. y que objetos son visibles por la cámara. Este algoritmo intenta resolver de manera eficiente este problema. </p>
<h2 id="¿Como-funciona"><a href="#¿Como-funciona" class="headerlink" title="¿Cómo funciona?"></a>¿Cómo funciona?</h2><p>La idea detras del algoritmo es bastante simple. Lo primero que se hace es definir para cada uno de los objetos que se quieren renderizar, la profundidad (que tan lejos de la camara) a la que esta. Esto lo hacemos para cada pixel del objeto. Además de esto, tambien se asigna un color a los pixeles, (el color de ese pixel en el objeto).  La forma mas facil de representar esto es usando matrices, cada columna representado la posicion en Y, y la columna la posicion X. Normalmente se asignan valores entre [0, 1] a la profunidad, pero eso ya depende de cada quien.<br>Una vez hecho esto, lo que prosigue es llenar el z buffer, que es el que nos va a ayudar a dibujar (se llama z buffer, porque guarda los valores de z para cada pixel). Inicialmente el buffer tendra en cada pixel el valor de infinito, indicando que no hay nada para dibujar. Luego empezamos a llenar el buffer con la informacion de cada objeto uno por uno, sin importar el orden en que se haga. Para cada pixel se mira la profundidad actual que tiene almacenada el buffer, y la del objeto. En caso de que el objeto tenga una profundidad menor, se actualiza el z buffer con la nueva profundidad, y el color que se debe pintar en ese pixel. Una vez procesados todos los objetos, solo resta dibujar la informacion que quedo en el buffer, y woala!, se vera una imagen con profundidad.</p>
<p><img src="https://i.imgur.com/SJZwXiv.jpg" alt="Imgur"></p>
<p>En la imagen de arriba se puede ver como va cambiando la matriz buffer a medida que se va procesando cada objeto que se queire renderizar.</p>
<h2 id="Pseudocodigo"><a href="#Pseudocodigo" class="headerlink" title="Pseudocodigo"></a>Pseudocodigo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Lista de poligonos &#123;</div><div class="line">    P_1, P_2, ..., P_n</div><div class="line">&#125;</div><div class="line">Se inicializa un array z-buffer[x,y] con Infinito</div><div class="line">Se declara un array Intensity[x,y]</div><div class="line">begin </div><div class="line">   for each polygon P in the polygon list do &#123;</div><div class="line">      for each pixel (x,y) that intersects P do &#123;</div><div class="line">         calculate z-depth of P at (x,y) </div><div class="line">	 if z-depth &lt; z-buffer[x,y] then &#123;</div><div class="line">            Intensity[x,y] = intensity of P at (x,y)</div><div class="line">	    z-buffer[x,y] = z-depth</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   Display  Intensity array </div><div class="line">end</div></pre></td></tr></table></figure>
<p>Como comentario final, me gustaria decir que la parte mas dificil del algoritmo es calcular la profundidad z de cada pixel de los objetos que se quieren renderizar.</p>
<p>Hasta la próxima.</p>
</article></main></body></html>